# 设计

## 约定

- 程序中的时间均采用`毫秒级时间戳`
- 程序中的`[]byte`在传输、保存等场景中，均使用16进制编码，以保证其正确性
    - 一些情况下，`[]byte`类型参数会被默认处理（例如go json marshal会对其执行base64编码），所以我们总是手动处理
- 使用`apifox`模拟前端请求，用于在服务端开发过程中测试接口
    - 完成开发后发现对应的`apifox`接口描述文件相对较大，且无法**一键测试**，遂决定使用go发送http请求、编写测试

## 总体设计

- `web`整体采用响应式设计：使用媒体查询当前屏幕宽度，使用不同的html、css
    - 因为web只是服务端程序配套的展示页面，所以为了偷点懒，我们在手机上删除了一批页面，这样可以少做一点适配（手机端没有个人中心）
    - html实现方式：`watch`屏幕宽度并保存到`pinia`，使用`pinia`+`v-if`决定展示哪一部分的html
    - css实现方式：`@media (min-width: 1280px) {}`

## 用户服务

- 只有登录功能返回token，前端创建用户成功之后自动调用一次登录
- 密码不使用明文，界面上输入密码后执行一次hash放入请求体、服务端保存的则是密码hash加盐之后的hash
    - req: `hex(hash('password text'))`
    - db: `hex(hash('pwd hash'+'salt'))`
    - hash algorithm: `sha256`
    - 前端执行hash的目的是，即使恶意攻击窃取了http请求参数，也无法恢复出密码明文，进而攻击者无法使用我们的ui；
      后端执行hash的目的是，即使恶意攻击窃取了数据库数据，也无法恢复出密码hash，进而无法调用接口。
- 服务端签发无状态的`token`，供客户端后续需要登录的接口调用
    - 登录成功时，服务端签发`token`，后续前端请求则需要带上该`token`
    - 用户服务通过请求头返回`token`参数给网关，网关根据参数签发`token`
    - 因为服务端没有任何保存，所以无法限制用户在多终端登录
