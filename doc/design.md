# 设计

## 约定

- 程序中的时间均采用`毫秒级时间戳`
- 程序中的`[]byte`在传输、保存等场景中，均使用16进制编码，以保证其正确性
    - 一些情况下，`[]byte`类型参数会被默认处理（例如go json marshal会对其执行base64编码），所以我们总是手动处理
- 使用`apifox`模拟前端请求，用于在服务端开发过程中测试接口
    - 完成开发后发现对应的`apifox`接口描述文件相对较大，且无法**一键测试**，遂决定使用go发送http请求、编写测试

## 总体设计

- `web`整体采用响应式设计：使用媒体查询当前屏幕宽度，使用不同的html、css
    - 因为web只是服务端程序配套的展示页面，所以为了偷点懒，我们在手机上删除了一批页面，这样可以少做一点适配（手机端没有个人中心）
    - html实现方式：`watch`屏幕宽度并保存到`pinia`，使用`pinia`+`v-if`决定展示哪一部分的html
    - css实现方式：`@media (min-width: 1280px) {}`
- 服务端签发无状态的`token`，供客户端后续需要登录的接口调用
    - hash algorithm: `hmac-sha256`
    - 登录成功时，服务端签发`token`，后续前端请求则需要带上该`token`
    - 用户服务通过请求头返回`token`参数给网关，网关根据参数签发`token`
    - 因为服务端没有任何保存，所以无法限制用户在多终端登录
- 密码不使用明文，界面上输入密码后执行一次hash放入请求体、服务端保存的则是密码hash加盐之后的hash
    - web: `hex(hash('password text'))`
    - db: `hex(hash('pwd hash'+'salt'))`
    - hash algorithm: `sha256`(web) / `argon2id`(db)
    - 前端执行hash的目的是，即使恶意攻击窃取了http请求参数，也无法恢复出密码明文，进而攻击者无法使用我们的ui；
      后端执行hash的目的是，即使恶意攻击窃取了数据库数据，也无法恢复出密码hash，进而无法调用接口。

## 用户服务

- 只有登录功能返回token，前端创建用户成功之后自动调用一次登录

## 数据库备份（导入/导出）

应用场景：更换服务器

整体规划：

- 导出：将数据库记录导出到文件
- 导入：将文件导入到数据库
- 下载：将备份文件从服务器下载到本地
- 上传：根据上传的文件执行导入

计划为所有可能有变化的数据表做备份，这里的备份更多是为了方便数据整体导入/导出。

为需要备份的表添加`exportID`、`exportedAt`字段

- `exportID`：数据编号，用于分页备份时标识该条记录应该放在哪个文件（其他字段均不具有该功能）
- `exportedAt`：上一次备份时间，如果该条记录在该时间后仍有修改(`updatedAt`)，则视为需要备份

方案概述：使用定时任务，例如每天搜索一次，将需要备份的数据都导出到文件

操作步骤：

- 查询要备份的数据表，条件是`exportedAt < updateAt`，分页查询，按照`exportID`升序排列
    - PageSize：100
- 根据`exportID`计算该条记录应该备份到的文件名
    - 文件名：`[table name]_[start id]to[end id].json`, e.g. `note_1to100.json`
- 打开目标文件，不存在则创建，读取文件内容并序列化到内存
    - 统一处理目标文件存在/不存在的情况
- 根据`exportID`是否匹配成功，修改文件中该条记录原本的值，或者新增一条记录，将结果写入文件（覆盖式写入）
- 设置`exportedAt`为当前时间，写回数据库

## 开发计划

- 为`note`编写淡入淡出特效
- 等26年2月，go语言出1.26正式版，改为使用go官方的日志库
