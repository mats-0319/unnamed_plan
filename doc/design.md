# 设计

## 约定

- 程序中的时间均采用`毫秒级时间戳`
- 程序中的`[]byte`在传输、保存等场景中，均使用16进制编码，以保证其可读性
- 使用`apifox`模拟前端请求，接口文件保存在`server/internal/http/api/apifox.openapi.json`
    - 用于在服务端开发过程中测试接口

## 总体设计

- `web`整体采用响应式设计：使用媒体查询当前屏幕宽度，使用不同的html、css
    - 因为web只是服务端程序配套的展示页面，所以为了偷点懒，我们在手机上删除了一批页面，这样可以少做一点适配（手机端没有个人中心）
    - html实现方式：`watch`屏幕宽度并保存到`pinia`，使用`pinia`+`v-if`决定展示哪一部分的html
    - css实现方式：`@media (min-width: 1280px) {}`
- 业务服务仅接受网关转发的请求
    - 网关转发请求时，将自身的host写到请求头`Origin`，业务服务读取并判断该请求头
    - 网关会同步转发前端的自定义请求头(req headers)和业务服务的自定义响应头(res headers)
    - 网关层保存和验证用户登录`token`

## 用户服务

- 只有登录功能返回token，前端创建用户成功之后自动调用一次登录
- 密码不使用明文，界面上输入密码后执行一次hash放入请求体、服务端保存的则是密码hash加盐之后的hash
    - req: `hex(hash('password text'))`
    - db: `hex(hash('pwd hash'+'salt'))`
    - hash algorithm: `sha256`
    - 前端执行hash的目的是，即使恶意攻击窃取了http请求参数，也无法恢复出密码明文，进而攻击者无法使用我们的ui；
      后端执行hash的目的是，即使恶意攻击窃取了数据库数据，也无法恢复出密码hash，进而无法调用接口。
- 使用服务端保存`token`的方式管理用户登录状态
    - 登录成功时，服务端签发`token`，后续前端请求则需要带上该`token`
    - `token`通过自定义`header`携带
    - 设计成服务端保存，是为了**限制一个用户同时只能登录在一台设备上**

## 小纸条服务

设计这个服务的目的是给整个项目添加一些实用性，虽然项目重点在于微服务架构，但是如果只有一个用户管理系统还是太单薄了。
所以我们设计了小纸条服务，注册用户可以写小纸条、而任何访问者都可以查看。
